# -*- coding: utf-8 -*-
"""Algo_with_Rerunning_part.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Hi0v5Hpmx9nIq5OwetXgg_eDpel-VkR

1.Check Max capacities of each plant and update them in the code  .
2.Properly add Rasath's Validation code to this   .
3.Find costs related to unit generation in each plant and update them in code   .
4.GUI Update    .
"""

import math
import numpy as np
# pip install geneticalgorithm
from geneticalgorithm import geneticalgorithm as ga
from GenerationPrediction import getSolarGeneration,getWindGeneration
from DemandPrediction import getDemandForecast

windForecast = getWindGeneration() 
solarForecast = getSolarGeneration()
demandForecast  = getDemandForecast()

# Constants and parameters
num_solar_plants = 5
num_wind_plants = 12
num_diesel_plants= 1
num_dendro_plants = 4
num_combined_cycles = 1
num_coal_plants= 2
num_storage_systems = num_solar_plants + num_wind_plants
num_Conventional_plants = num_coal_plants+ num_diesel_plants+ num_dendro_plants+num_combined_cycles
beta = 0.5
initial_storage_percentage = 0.5

# Example forecasted generation for the next hour (replace with actual values)
forecasted_solar_generation = np.array([solarForecast[0], solarForecast[1], solarForecast[2], solarForecast[3], solarForecast[4]])  # example MW for each solar plant (5 plants)
forecasted_wind_generation = np.array([windForecast[0], windForecast[1], windForecast[2],windForecast[3],windForecast[4],windForecast[5],windForecast[6],windForecast[7],windForecast[8],windForecast[9],windForecast[10],windForecast[11]])  # example MW for each wind plants(12 plants)
forecasted_loads = np.array([demandForecast[0], demandForecast[1], demandForecast[2], demandForecast[3], demandForecast[4],demandForecast[5],demandForecast[6],demandForecast[7],demandForecast[8],demandForecast[9],demandForecast[10]])  # example MW forecasted load for each place in the network (11 demands)

# Example maximum generation values for each plant
max_generation_values_conventional = np.array([120, 150, 100, 300, 230, 60,70,80])  # example Maximum generation for each plant in MW (8 plants)
max_generation_values_solar_wind = np.array([120, 150, 90, 110, 130, 90, 120, 80, 100,30,40,50,60,70,80,80,90]) # example value set
max_storages = 0.1 * max_generation_values_solar_wind

# Example costs and parameters for the objective function
cost_conventional = np.array([30, 35,30,30,30,30,30,30])  # example values of Cost of generating electricity from conventional plants in $/MWh
cost_storage = np.array([5, 5, 5, 5, 5, 5, 5, 5,5,5,5,5,5,5,5,5,5])  # example values of Cost of storing electricity in batteries in $/MWh
penalty_factor = 0.01  # Penalty factor for transmission and line losses
weight_renewable_utilization = 0.2  # Weight for maximizing the utilization of renewable energy

# Initial charge levels for each storage system (as a fraction)
initial_charge_levels = np.full(num_solar_plants + num_wind_plants, initial_storage_percentage)

# Define the modified objective function
def modified_objective_function(x):
    conventional_dispatch = x[:num_Conventional_plants]
    renewable_dispatch = x[num_Conventional_plants:num_Conventional_plants + num_solar_plants + num_wind_plants]
    storage_dispatch = x[num_Conventional_plants + num_solar_plants + num_wind_plants:min(num_Conventional_plants + num_solar_plants + num_wind_plants + num_storage_systems, len(x))]

    # Calculate total generation for each plant
    total_generation = np.concatenate([renewable_dispatch, conventional_dispatch])

    # Calculate total cost
    total_cost = np.sum(cost_conventional[:num_Conventional_plants] * conventional_dispatch) + np.sum(cost_storage * storage_dispatch)
    total_cost += penalty_factor * np.sum(total_generation ** 2)  # Transmission and line losses penalty
    total_cost -= weight_renewable_utilization * np.sum(renewable_dispatch)
    total_cost -= beta * np.sum(renewable_dispatch)  # Utilization of renewable energy term

    return total_cost

# Define the variable bounds for the dispatch
varbound = []
# Loop for conventional plants
for i in range(num_Conventional_plants):
    varbound.append((25, max_generation_values_conventional[i]))

# Loop for renewable plants and storage systems
for i in range(num_solar_plants + num_wind_plants):
    varbound.append((0, max_generation_values_solar_wind[i]))

for i in range(num_storage_systems):
    varbound.append((0, max_storages[i]))

# Convert the list of tuples to a NumPy array
varbound = np.array(varbound)

# Define the GA parameters
algorithm_param = {'max_num_iteration': 1000, 'population_size': 1000, 'mutation_probability': 0.1,
                   'elit_ratio': 0.01, 'crossover_probability': 0.5, 'crossover_type': 'uniform',
                   'max_iteration_without_improv': None, 'parents_portion': 0.5, 'save_best_solutions': True}

# Function to calculate reactive power (Q) from active power (P) and power factor (PF)
def calculate_reactive_power(P, PF):
    return P * math.sqrt((1 / PF**2) - 1)

# Function to run the GA and validate the results
def run_ga_and_validate():
    # Re-run the GA optimization
    model = ga(
        function=modified_objective_function,
        dimension=num_Conventional_plants + num_solar_plants + num_wind_plants + num_storage_systems,
        variable_type='real',
        variable_boundaries=varbound,
        algorithm_parameters=algorithm_param
    )
    model.run()

    # Get the GA-optimized dispatch values
    ga_optimized_dispatch = model.output_dict['variable']

    # Get the least cost
    least_cost = model.output_dict['function']

    # Extract storage dispatch values from the optimized dispatch values
    current_storage_dispatch = ga_optimized_dispatch[num_Conventional_plants + num_solar_plants + num_wind_plants:]

    # Create the new list with active and reactive power values:
    Final_Dispatch_Output = []
    power_factor = 0.9
    for P in ga_optimized_dispatch[:num_storage_systems]:
        Q = calculate_reactive_power(P, power_factor)
        Final_Dispatch_Output.append(P)
        Final_Dispatch_Output.append(Q)

    print('Final Dispatch Array', Final_Dispatch_Output)

    export_data = {}
    export_data["final_dispatch_array"]= Final_Dispatch_Output


    # Create the final load forecast list
    Final_forecasted_Loads = []
    for P in forecasted_loads:
        Q = calculate_reactive_power(P, power_factor)
        Final_forecasted_Loads.append(P)
        Final_forecasted_Loads.append(Q)

    print("Final Load Forecasts", Final_forecasted_Loads)
    export_data["final_load_forecsts"]= Final_forecasted_Loads
    

    # passing output values of Genetic algorithm to Rasath's Validation code part

    # valueList = openDssFunction(Final_Dispatch_Output, Final_forecasted_Loads)

    # print(valueList)

    # Then here running the validation code.....
    # Rasath's part .....

    voltage1 = 230.0  # (example values for Rasath's outputs)
    voltage2 = 230.0  # (example values for Rasath's outputs)

    # Predefined maximum and minimum voltage thresholds
    max_voltage_threshold = 240.0
    min_voltage_threshold = 220.0

    # Check if the maximum voltage is greater than the max threshold
    if max(voltage1, voltage2) > max_voltage_threshold:
        print("Validation fail: Maximum voltage exceeds threshold")
        return False

    # Check if the minimum voltage is less than the min threshold
    elif min(voltage1, voltage2) < min_voltage_threshold:
        print("Validation fail: Minimum voltage is below threshold")
        return False

    # If both checks pass, validation is successful
    else:
        print("Validation pass")
        # Format the output and print the output dispatch values, if validation is passed.
        for i in range(num_solar_plants):
            export_data[f"solar_plant_{i+1}"]= round(ga_optimized_dispatch[num_Conventional_plants + i], 3)
            print(f"Power dispatch output of solar power plant {i + 1}: {round(ga_optimized_dispatch[num_Conventional_plants + i], 3)}")

        for i in range(num_wind_plants):
            export_data[f"wind_plant_{i+1}"]= round(ga_optimized_dispatch[num_Conventional_plants + num_solar_plants + i], 3)
            print(f"Power dispatch output of wind power plant {i + 1}: {round(ga_optimized_dispatch[num_Conventional_plants + num_solar_plants + i], 3)}")

        for i in range(num_storage_systems):
            export_data[f"storage_of_renewable_plant_{i+1}"]= round(current_storage_dispatch[i], 3)
            print(f"Power dispatch output of storage of renewable plant {i + 1}: {round(current_storage_dispatch[i], 3)}")

        for i in range(num_Conventional_plants):
            export_data[f"conventional_plant_{i+1}"]= round(max_generation_values_conventional[i], 3)
            print(f"Power dispatch output of Conventional plant {i + 1}: {round(max_generation_values_conventional[i], 3)}")

        print(export_data)
        return True

# Main loop to rerun the GA until validation passes
while not run_ga_and_validate():
    print("Rerunning GA optimization due to validation failure...")